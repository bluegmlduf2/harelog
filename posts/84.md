---
title: "구글의 OAuth에 대해서 ( + 액세스토큰 로그인 방식 )"
date: 2023-11-26
category: others
---

### 인증용어

리소스오너 : 사용자

클라이언트 : 사용자가 사용할 앱

리소스서버 : 구글서버

코드 : 클라이언트가 해당 서비스(구글카렌더등)를 이용하기 위한 인증코드이며 사용자가 화면에서 허가한다

액세스토큰 : 클라이언트앱이 리소스서버로부터 인증받으면 발급되는 토큰 (보통 클라이언트에서 한시간 정도 보관하고 리소스서버에서 폐기함)

SDK : 구글등의 리소스서버가 제공하는 인증 라이브러리(클라리언트에서 개발시 사용)

클라이언트ID/시크릿키 : 리소스서버로부터 클라이언트앱 인증용

스코프리스트 : 클라이언트앱에서 리소스서버에 사용할 기능리스트(카렌더 보기,카렌더 다운로드등..)

### 구글의 카렌더 기능을 클라이언트에서 사용하는 과정

1. 리소스오너(사용자)가 해당 클라이언트(앱)를 사용하기위해 해당 클라이언트의 화면을 연다
2. 리소스오너가 구글에 로그인되어있지않다면 로그인을 요구한다
3. 리소스오너가 로그인 되었다면 클라이언트가 카렌더 기능을 사용하도록 허가하겠냐고 묻는다

   (클라이언트는 리소스서버로부터 발급받은 클라이언트ID와 시크릿키를 가지고있는 상태)
4. 위의 내용이 확인되면 리소스서버(구글)가 클라이언트에게 코드라는 것을 보낸다
5. 클라이언트는 받은 코드와 클라이언트ID와 시크릿키 3개를 리소스 서버에 보낸다
6. 위의 5번의 과정으로 클라이언트는 구글에게 허가받은 앱임을 클라이언트ID/시크릿키을 통해서 인증하고, 해당 카렌더 서비스를 사용 가능할수있음을 코드를 통해서 인증할수있다
7. 클라이언트ID와 시크릿키 코드를 받은 리소스서버는 클라이언트에게 액세스키를 발급하고 클라이언트는 이를 저장한다
8. 클라이언트는 리소스서버에 액세스토큰을 사용해서 사용자의 구글 카렌더 데이터를 받아온다
9. 앞서서 받아온 카렌더 데이터를 클라이언트는 리소스오너(사용자)에게 보낸다

### Client Id / Secret Key 에 대해서 ( 0528추가 )

1. **Client ID** : 내가 OAuth를 사용할 웹 어플리케이션을 구별할 수 있는 식별자이다. 노출되어도 된다 ( 내 프로젝트의 고유의 ID라고 생각하면됨 )
2. **Client Secret** : 위의 Client ID에 대한 비밀키이다. 절대 노출해서는 안된다.

### OAuth란

사용자가 Google이나 Facebook의 소셜 계정으로 외부 어플리케이션에 간단히 회원가입/로그인/사용 할수있는 기능이다

또한 해당 외부 어플리케이션에서 Google과 Facebook이 제공하는 기능을 간편하게 사용가능하다 ( ex: 구글 카렌더 )

## 액세스토큰

- 권한 확인을 위해서 사용됨

- 액세스토큰을 구현하는 방식중에 하나가 JWT이다 ( [내 사이트 JWT 정리참조](/posts/279fd5a9-6b51-11ed-b286-06db0157c20f#:~:text=%EA%B2%BD%EC%9A%B0%EC%97%90%EB%8F%84%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C%20%EC%82%AD%EC%A0%9C%EB%90%9C%EB%8B%A4-,%ED%86%A0%ED%81%B0(jwt),-jwt%20%ED%86%A0%ED%81%B0%20%ED%98%95%EC%8B%9D%EC%9D%80) )

- jwt는 비대칭키를 사용하므로 클라이언트에 인증정보를 저장가능하다

- 기본적으로 세션을 이용한 로그인 방식과 다르다 ( [내 사이트 세션 로그인방식 정리 참조](/posts/279fd5a9-6b51-11ed-b286-06db0157c20f#:~:text=%EC%84%B8%EC%85%98%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EA%B5%AC%EC%A1%B0%20(0529%EC%B6%94%EA%B0%80)) )

- 세션로그인 방식은 유저의 인증정보를 서버에 저장하여 서버의 부하를 늘리지만

액세스토큰 방식은 유저의 인증정보를 클라이언트에 저장하기때문에 서버의 부하가 적다

- 서버와 클라이언트 사이에 엑세스 토큰을 주고 받을때 헤더의 Authorization에 아래와 같이 설정한다

```
headers: {
  "Content-Type": "application/json",
  "Authorization": `Bearer ${accessToken}`
}
```

---

**참조**

[생활코딩](https://www.youtube.com/watch?v=PIlP_YX5HK8)

[OAuth란](https://tecoble.techcourse.co.kr/post/2021-07-10-understanding-oauth/)

[액세스토큰 방식](https://velog.io/@boo1996/Token)
